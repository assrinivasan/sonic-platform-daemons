#!/usr/bin/env python3

"""
    storagemond
    Strage Monitoring device monitoring daemon for SONiC
"""

import os
import signal
import sys
import threading
import subprocess
import shutil

from sonic_py_common import daemon_base, device_info, logger
from swsscommon import swsscommon
from sonic_platform_base.sonic_storage.storage_devices import StorageDevices

#
# Constants ====================================================================
#

# TODO: Once we no longer support Python 2, we can eliminate this and get the
# name using the 'name' field (e.g., `signal.SIGINT.name`) starting with Python 3.5
SIGNALS_TO_NAMES_DICT = dict((getattr(signal, n), n)
                             for n in dir(signal) if n.startswith('SIG') and '_' not in n)

SYSLOG_IDENTIFIER = "storagemond"

STORAGE_DEVICE_TABLE_NAME = "STORAGE_INFO"

STORMOND_MAIN_THREAD_SLEEP_SECS = 3600 #one hour

STORAGEUTIL_LOAD_ERROR = 127

log = logger.Logger(SYSLOG_IDENTIFIER)

exit_code = 0

#
# Daemon =======================================================================
#


class DaemonStorage(daemon_base.DaemonBase):
    def __init__(self, log_identifier):
        super(DaemonStorage, self).__init__(log_identifier)

        self.timeout = STORMOND_MAIN_THREAD_SLEEP_SECS
        self.stop_event = threading.Event()
        self.state_db = None
        self.device_table = None
        self.storage = StorageDevices(log_identifier)

        self.static_fields = ["device_model", "serial"]
        self.dynamic_fields = ["firmware", "health", "temperature", "fs_io_reads", "fs_io_writes", "disk_io_reads", "disk_io_writes", "reserved_blocks"]

        self.read_static_fields = dict((disk, False) for disk in self.storage.devices)
        self.updated_static_fields_statedb = dict((disk, False) for disk in self.storage.devices)

        # Connect to STATE_DB and create Storage device table
        self.state_db = daemon_base.db_connect("STATE_DB")
        self.device_table = swsscommon.Table(self.state_db, STORAGE_DEVICE_TABLE_NAME)

    def __del__(self):
        if self.device_table:
            table_keys = self.device_table.getKeys()
            for tk in table_keys:
                self.device_table._del(tk)


    # Update the Storage device info to State DB
    def update_storage_info_status_db(self, disk_device, disk_fields, kvp_dict):

        for field in disk_fields:
            fvp = swsscommon.FieldValuePairs([(field, str(kvp_dict[field]))])
            self.device_table.set(disk_device, fvp)


    # Get Static attributes and update the State DB, once
    def get_static_fields(self):

        # Get relevant information about each Storage Device on the switch
        for storage_device in self.storage.devices:
            try:
                if self.storage.devices[storage_device] is None:
                    self.log_warning("{} does not have an instantiated object. Static Information cannot be gathered.".format(storage_device))
                    continue

                if self.read_static_fields[storage_device] and self.updated_static_fields_statedb[storage_device]:
                    self.log_info("Static information from {} has already been parsed and updated to StateDB.".format(storage_device))
                    continue

                static_kvp_dict = dict((field, "") for field in self.static_fields)

                static_kvp_dict["device_model"] = self.storage.devices[storage_device].get_model()
                static_kvp_dict["serial"] = self.storage.devices[storage_device].get_serial()

                self.log_info("Storage Device: {}, Device Model: {}, Serial: {}".format(storage_device, static_kvp_dict["device_model"], static_kvp_dict["serial"]))
                self.read_static_fields[storage_device] = True

                # update Storage Device Status to DB
                self.update_storage_info_status_db(storage_device, self.static_fields, static_kvp_dict)
                self.updated_static_fields_statedb[storage_device] = True

            except Exception as ex:
                self.log_warning("get_static_fields() failed with: {}".format(str(ex)))

    # Get Dynamic attributes and update the State DB
    def get_dynamic_fields(self):

        # Get relevant information about each storage disk on the device
        for storage_device in self.storage.devices:
            try:
                if self.storage.devices[storage_device] is None:
                    self.log_warning("{} does not have an instantiated object. Dynamic Information cannot be gathered.".format(storage_device))
                    continue

                dynamic_kvp_dict = dict((field, "") for field in self.dynamic_fields)

                dynamic_kvp_dict["firmware"] = self.storage.devices[storage_device].get_firmware()
                dynamic_kvp_dict["health"] = self.storage.devices[storage_device].get_health()
                dynamic_kvp_dict["temperature"] = self.storage.devices[storage_device].get_temperature()
                dynamic_kvp_dict["fs_io_reads"] = self.storage.devices[storage_device].get_fs_io_reads()
                dynamic_kvp_dict["fs_io_writes"] = self.storage.devices[storage_device].get_fs_io_writes()
                dynamic_kvp_dict["disk_io_reads"] = self.storage.devices[storage_device].get_disk_io_reads()
                dynamic_kvp_dict["disk_io_writes"] = self.storage.devices[storage_device].get_disk_io_writes()
                dynamic_kvp_dict["reserved_blocks"] = self.storage.devices[storage_device].get_reserved_blocks()

                self.log_info("Storage Device: {}, Firmware: {}, health: {}%, Temp: {}C, FS IO Reads: {}, FS IO Writes: {}".format(\
                storage_device, dynamic_kvp_dict["firmware"], dynamic_kvp_dict["health"], dynamic_kvp_dict["temperature"], dynamic_kvp_dict["fs_io_reads"],dynamic_kvp_dict["fs_io_writes"],))
                self.log_info("Disk IO Reads: {}, Disk IO Writes: {}, Reserved Blocks: {}".format(dynamic_kvp_dict["disk_io_reads"], dynamic_kvp_dict["disk_io_writes"], \
                dynamic_kvp_dict["reserved_blocks"]))

                # update Storage Device Status to DB
                self.update_storage_info_status_db(storage_device, self.dynamic_fields, dynamic_kvp_dict)

            except Exception as ex:
                self.log_warning("get_dynamic_fields() failed with: {}".format(str(ex)))


   # Override signal handler from DaemonBase
    def signal_handler(self, sig, frame):
        FATAL_SIGNALS = [signal.SIGINT, signal.SIGTERM]
        NONFATAL_SIGNALS = [signal.SIGHUP]

        global exit_code

        if sig in FATAL_SIGNALS:
            self.log_info("Caught signal '{}' - exiting...".format(SIGNALS_TO_NAMES_DICT[sig]))
            exit_code = 128 + sig  # Make sure we exit with a non-zero code so that supervisor will try to restart us
            self.stop_event.set()
        elif sig in NONFATAL_SIGNALS:
            self.log_info("Caught signal '{}' - ignoring...".format(SIGNALS_TO_NAMES_DICT[sig]))
        else:
            self.log_warning("Caught unhandled signal '{}' - ignoring...".format(SIGNALS_TO_NAMES_DICT[sig]))

    # Main daemon logic
    def run(self):
        if self.stop_event.wait(self.timeout):
            # We received a fatal signal
            return False

        # Read and update Static Fields to the StateDB once
        self.get_static_fields()

        # Repeatedly read and update Dynamic Fields to the StateDB
        self.get_dynamic_fields()

        return True
#
# Main =========================================================================
#


def main():
    stormon = DaemonStorage(SYSLOG_IDENTIFIER)

    stormon.log_info("Starting Storage Monitoring Daemon")

    while stormon.run():
        pass

    stormon.log_info("Shutting down Storage Monitoring Daemon")

    return exit_code

if __name__ == '__main__':
    sys.exit(main())
